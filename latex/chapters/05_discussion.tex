\chapter{Implementação}
\label{ch:implementation}

Nesse capítulo serão explicadas as particularidades de cada implementacão das funcões mencionadas no capítulo anterior. Também serão elucidados alguns aspectos exclusivos da linguagem Rust, primeiramente abordando algumas decisões de arquitetura e em seguida falando sobre as 3 estruturas de dados implementadas.

\section{Arquitetura}

Como já citado no capítulos anterior, dado que haveriam implementações de funções em comum para estruturas de dados diferentes, grafo e dígrafo foram implementados através de \texttt{traits}, da seguinte forma:

\begin{lstlisting}[language=Rust, caption={Implementação do trait Graph}, label=list:trait_graph]
pub trait Graph<Node: Eq + Hash + Copy> {
    fn new_empty() -> Self;

    fn order(&self) -> usize;

    fn size(&self) -> usize;

    fn node_degrees(&self, n: Node) -> (usize, usize);

    fn nodes(&self) -> impl Iterator<Item = Node>;

    fn add_node(&mut self, n: Node);

    fn remove_node(&mut self, n: Node);

    fn add_edge(&mut self, n: Node, m: Node);

    fn remove_edge(&mut self, n: Node, m: Node);

    type Neighbors<'a>: Iterator<Item = Node>
    where
        Self: 'a,
        Node: 'a;
    fn neighbors<'a>(&'a self, n: Node) -> Self::Neighbors<'a>;

    fn biparted(&self) -> bool;

    fn underlying_graph(&self) -> Self;

    fn has_edge(&self, n: Node, m: Node) -> bool {
        self.neighbors(n).any(|neighbor| neighbor == m)
    }

    fn dfs(&self, start: Node) -> DfsIter<'_, Node, Self>
    where
        Self: Sized,
    {
        DfsIter::new(self, start)
    }

    fn bfs(&self, start: Node) -> BfsIter<'_, Node, Self>
    where
        Self: Sized,
    {
        BfsIter::new(self, start)
    }

    fn classify_edges(&self, start: Node) -> DfsEdgesIter<'_, Node, Self>
    where
        Self: Sized,
    {
        DfsEdgesIter::new(self, start)
    }
}
\end{lstlisting}

As particularidades da sintaxe acima são que, \texttt{Graph} pode ser implementado para qualquer tipo genérico \texttt{N}, desde que este implemente os seguintes \texttt{traits}:

\begin{itemize}
  \item \textbf{Eq}: Que dá ao tipo a propriedade de igualdade através do operador ==
  \item \textbf{Hash}: Propriedade necessária para que aquele tipo possa ser usado em estruturas de dados como \texttt{HashMap/HashSet}. Que serão usadas em trabalhos futuros.
  \item \textbf{Copy}: Que dá ao tipo a propriedade de ser copiável através do operador =, o que apesar de parecer trivial, não é. E isso acontece pois Rust introduz o conceito de \cite{ownership}, que faz com que nem todo tipo seja copiável.
\end{itemize}

Feito isso, basta com que o tipo implementa as funções com as assinaturas solicitadas e ele terá o \texttt{trait Graph}. E além dele, também temos outro \texttt{trait} que tem ele como pré-requisito para implementação, o \texttt{UndirectedGraph}:

\begin{lstlisting}[language=Rust, caption={Implementação do trait UndirectedGraph}, label=list:trait_undirected_graph]
pub trait UndirectedGraph<Node: Copy + Eq + Hash>: Graph<Node> {
    fn undirected_size(&self) -> usize;

    fn connected(&self) -> bool;

    fn biconnected_components(&self, start: Node) -> BiconnectedComponentsIter<'_, Node, Self>
    where
        Self: Sized,
    {
        BiconnectedComponentsIter::new(self, start)
    }

    fn add_undirected_edge(&mut self, n: Node, m: Node) {
        self.add_edge(n, m);
        self.add_edge(m, n);
    }

    fn remove_undirected_edge(&mut self, n: Node, m: Node) {
        self.remove_edge(n, m);
        self.remove_edge(m, n);
    }

    fn undirected_node_degree(&self, n: Node) -> usize {
        self.neighbors(n).count()
    }

    fn classify_undirected_edges<'a>(&'a self, start: Node) -> impl Iterator<Item = Edge<Node>>
    where
        Self: Sized,
        Node: 'a,
    {
        DfsEdgesIter::new(self, start)
            .filter(|edge| matches!(edge, Edge::Tree(_, _) | Edge::Back(_, _)))
    }
}
\end{lstlisting}

Note que o \texttt{trait} já tem várias implementações, e isso só é possível pois ele usa as funcões já implementadas em \texttt{Graph}. Por isso que implementar \texttt{UndirectedGraph}, antes, é necessário implementar esse.

Mas feitas as considerações iniciais acerca da arquitetura da implementação, podemos abordar as particularidades de cada Estrutura da Dados.

\section{Matriz de Adjacência}

A Matriz de Adjacência, conforme falado anteriormente, é uma das formas mais comuns de se implementar um grafo. Muito disso em decorrência de sua baixa complexidade na inserção e no acesso nos elementos. Sendo assim, ela é implementada da seguinte forma:

\begin{lstlisting}[language=Rust, caption={Implementação da Estrutura de Dados Matriz de Adjacência}, label=list:struct_adj_mat]
#[derive(Debug, Clone)]
pub struct AdjacencyMatrix(pub Vec<Vec<usize>>);
\end{lstlisting}

No código acima, o \texttt{derive} é uma instrução para o compilador inferir como adicionar as pripriedades \texttt{Debug} e \texttt{Clone} na estrutura abaixo. Estrutura essa que consiste em um vetor de vetores de \texttt{usize}(inteiros não-negativos, tipo usado para fins de simplificação, uma vez que temos mais garantias sobre as propridades dele dessa forma, diferente de em tipos genéricos). E abaixo segue a implementação das funções solicitadas pelo \texttt{trait UndirectedGraph}.

\begin{lstlisting}[language=Rust, caption={Implementação de UndirectedGraph na Estrutura de Dados Matriz de Adjacência}, label=list:impl_adj_mat_ug] impl UndirectedGraph<usize> for AdjacencyMatrix {
    fn undirected_size(&self) -> usize {
        let mut size = 0;
        for i in 0..self.order() {
            for j in 0..=i {
                if self.0[i][j] > 0 {
                    size += 1;
                }
            }
        }
        size
    }

    fn connected(&self) -> bool {
        let n = self.order();
        if n == 0 {
            return true;
        }

        let mut visited = vec![false; n];
        let mut stack = vec![0];
        visited[0] = true;

        while let Some(u) = stack.pop() {
            for (v, &is_edge) in self.0[u].iter().enumerate() {
                if is_edge > 0 && !visited[v] {
                    visited[v] = true;
                    stack.push(v);
                }
            }
        }

        visited.into_iter().all(|v| v)
    }

    fn undirected_node_degree(&self, node: usize) -> usize {
        if let Some(row) = self.0.get(node) {
            row.iter().filter(|&&val| val != 0).count()
        } else {
            0
        }
    }
}
\end{lstlisting}

Note que ele só define as funções que não tem implementação padrão. E algo que também importante para se pontuar é que a palavra \texttt{mut}(abreviação de "mutável") é requerida sempre que desejamos alterar o valor da variável em questão, pois devemos fazer isso de forma explícita, e isso acontece por conta do conceito de \cite{ownership}. E abaixo segue a implementação de \texttt{Graph}:

\begin{lstlisting}[language=Rust, caption={Implementação de Graph na Estrutura de Dados Matriz de Adjacência}, label=list:impl_adj_mat_g]
impl Graph<usize> for AdjacencyMatrix {
    fn new_empty() -> Self {
        AdjacencyMatrix(vec![])
    }

    fn order(&self) -> usize {
        self.0.len()
    }

    fn size(&self) -> usize {
        self.0
            .iter()
            .enumerate()
            .map(|(i, _)| self.neighbors(i).count())
            .sum()
    }

    fn node_degrees(&self, n: usize) -> (usize, usize) {
        let out_deg = self.0[n].iter().filter(|&&v| v != 0).count();
        let in_deg = self.0.iter().filter(|row| row[n] != 0).count();
        (in_deg, out_deg)
    }

    fn nodes(&self) -> impl Iterator<Item = usize> {
        0..self.order()
    }

    fn add_node(&mut self, _n: usize) {
        self.0.push(Vec::new());
        let new_order = self.order();

        for r in &mut self.0 {
            while r.len() < new_order {
                r.push(0);
            }
        }
    }

    fn remove_node(&mut self, n: usize) {
        if n < self.0.len() {
            self.0.remove(n);
            for row in self.0.iter_mut() {
                for idx in n + 1..row.len() {
                    row[idx - 1] = row[idx];
                }
                row.pop();
            }
        }
    }

    fn add_edge(&mut self, n: usize, m: usize) {
        if let Some(edges) = self.0.get_mut(n)
            && let Some(edge) = edges.get_mut(m)
        {
            if *edge == 1 {
                return;
            }
            *edge = 1;
        }
    }

    fn remove_edge(&mut self, n: usize, m: usize) {
        if let Some(edges) = self.0.get_mut(n)
            && let Some(edge) = edges.get_mut(m)
        {
            *edge = 0;
        }
    }

    type Neighbors<'a> = std::iter::FilterMap<
        std::iter::Enumerate<std::slice::Iter<'a, usize>>,
        fn((usize, &'a usize)) -> Option<usize>,
    >;

    fn neighbors<'a>(&'a self, n: usize) -> Self::Neighbors<'a> {
        fn filter_fn((i, &weight): (usize, &usize)) -> Option<usize> {
            if weight != 0 { Some(i) } else { None }
        }
        match self.0.get(n) {
            Some(row) => row.iter().enumerate().filter_map(filter_fn),
            None => [].iter().enumerate().filter_map(filter_fn),
        }
    }

    fn biparted(&self) -> bool {
        let n = self.order();
        if n == 0 {
            return true;
        }

        let mut side = vec![None; n]; // None = uncolored, Some(0/1) = partition
        let mut queue = std::collections::VecDeque::new();

        for start in 0..n {
            // skip already colored components
            if side[start].is_some() {
                continue;
            }

            side[start] = Some(0);
            queue.push_back(start);

            while let Some(u) = queue.pop_front() {
                let u_side = side[u].unwrap();

                for (v, &is_edge) in self.0[u].iter().enumerate() {
                    if is_edge == 0 {
                        continue;
                    }

                    if side[v].is_none() {
                        side[v] = Some(1 - u_side);
                        queue.push_back(v);
                    } else if side[v] == Some(u_side) {
                        return false; // adjacent nodes with same color
                    }
                }
            }
        }

        true
    }

    fn underlying_graph(&self) -> Self {
        let mut matrix: AdjacencyMatrix =
            AdjacencyMatrix(vec![vec![0; self.0.len()]; self.0.len()]);

        for (idx_r, row) in self.0.iter().enumerate() {
            for (idx_c, col) in row.iter().enumerate() {
                if *col == 1 && !matrix.has_edge(idx_c, idx_r) {
                    matrix.add_undirected_edge(idx_r, idx_c);
                }
            }
        }

        matrix
    }
}
\end{lstlisting}

Perceba que funções como \texttt{underlying graph} recorrem a funções definidas em \texttt{UndirectedGraph}, e isso ocorre pois os \texttt{traits} tem acesso mútuo entre as funções definidas pelos tipos que os implementam.

\section{Lista de Adjacência}

Juntamente com a Matriz de Adjacência, a lista de Adjacência é uma das implementações mais comum usadas para grafos. Sua natureza de tamanho dinâmico é usada principalmente para problemas que envolvem muitos vértices e arestas, sendo assim, sua implementação em Rust se dá da seguinte forma:

\begin{lstlisting}[language=Rust, caption={Implementação de Graph na Estrutura de Dados Matriz de Adjacência}, label=list:impl_adj_mat_g]
#[derive(Debug, Clone, Default)]
pub struct AdjacencyList(pub Vec<Vec<usize>>);
\end{lstlisting}

Perceba que é análoga à matriz de adjacência, com exceção do \texttt{Default} que cria um comportamento padrão de instanciar a estrutura através de um vetor vazio. E sua implementação de \texttt{UndirectedGraph} é a seguinte:

\begin{lstlisting}[language=Rust, caption={Implementação de Graph na Estrutura de Dados Matriz de Adjacência}, label=list:impl_adj_list_ug]
impl UndirectedGraph<usize> for AdjacencyList {
    fn undirected_size(&self) -> usize {
        let mut self_loops = 0;
        let regular_edges: usize = self
            .0
            .iter()
            .enumerate()
            .map(|(i, _)| {
                self.neighbors(i)
                    .filter(|&n| {
                        let is_self_loop = n == i;
                        self_loops += is_self_loop as usize;
                        !is_self_loop
                    })
                    .count()
            })
            .sum();
        regular_edges / 2 + self_loops
    }

    fn connected(&self) -> bool {
        for i in 0..self.order() {
            if self
                .dfs(i)
                .filter(|event| matches!(event, DfsEvent::Discover(_, _)))
                .count()
                != self.order()
            {
                return false;
            }
        }
        true
    }

    fn undirected_node_degree(&self, node: usize) -> usize {
        self.0
            .get(node)
            .map(|neighbors| neighbors.len())
            .unwrap_or(0)
    }
}
\end{lstlisting}

Perceba que, dada a natureza de continuidade de "valores significativos"(ao contrário da Matriz de Adjacência, que, por vezes, tem várias ocorrências de 0), a Estrutura de Dados em questão é muito iterável. Sendo assim, o conteúdo da maioria das funções consiste na chamada de vários métodos em sequência. E o mesmo se aplica para a implementacão de \texttt{Graph}, que recorer muito pouco a laços:

\begin{lstlisting}[language=Rust, caption={Implementação de Graph na Estrutura de Dados Matriz de Adjacência}, label=list:impl_adj_list_g]
impl Graph<usize> for AdjacencyList {
    fn new_empty() -> Self {
        AdjacencyList(vec![])
    }

    fn order(&self) -> usize {
        self.0.len()
    }

    fn size(&self) -> usize {
        self.0.iter().map(|neighbors| neighbors.len()).sum()
    }

    fn node_degrees(&self, n: usize) -> (usize, usize) {
        let out_deg = self.0.get(n).map_or(0, |neighbors| neighbors.len());
        let in_deg = self
            .0
            .iter()
            .filter(|neighbors| neighbors.contains(&n))
            .count();
        (in_deg, out_deg)
    }

    fn nodes(&self) -> impl Iterator<Item = usize> {
        0..self.order()
    }

    fn add_node(&mut self, _n: usize) {
        self.0.push(Vec::new());
    }

    fn remove_node(&mut self, n: usize) {
        if n < self.0.len() {
            self.0.remove(n);
            for neighbors in self.0.iter_mut() {
                neighbors.retain(|&x| x != n);
                for x in neighbors.iter_mut() {
                    if *x > n {
                        *x -= 1;
                    }
                }
            }
        }
    }

    fn add_edge(&mut self, n: usize, m: usize) {
        if self.0.get(m).is_some()
            && let Some(n_edges) = self.0.get_mut(n)
            && !n_edges.contains(&m)
        {
            n_edges.push(m);
        }
    }

    fn remove_edge(&mut self, n: usize, m: usize) {
        if let Some(edges) = self.0.get_mut(n) {
            edges.retain(|&x| x != m);
        }
    }

    type Neighbors<'a> = std::iter::Copied<std::slice::Iter<'a, usize>>;

    fn neighbors<'a>(&'a self, n: usize) -> Self::Neighbors<'a> {
        match self.0.get(n) {
            Some(edges) => edges.iter().copied(),
            None => [].iter().copied(),
        }
    }

    fn biparted(&self) -> bool {
        let n = self.order();
        if n == 0 {
            return true;
        }

        let mut side = vec![None; n];

        for start in 0..n {
            if side[start].is_some() {
                continue;
            }
            side[start] = Some(0);
            let mut queue = std::collections::VecDeque::new();
            queue.push_back(start);

            while let Some(u) = queue.pop_front() {
                let u_side = side[u].unwrap();
                for v in self.neighbors(u) {
                    if side[v].is_none() {
                        side[v] = Some(1 - u_side);
                        queue.push_back(v);
                    } else if side[v] == Some(u_side) {
                        return false;
                    }
                }
            }
        }

        true
    }

    fn underlying_graph(&self) -> Self {
        let mut list = AdjacencyList(vec![Vec::new(); self.0.len()]);

        for (idx_r, row) in self.0.iter().enumerate() {
            for &col in row.iter() {
                if !list.has_edge(idx_r, col) {
                    list.add_undirected_edge(idx_r, col);
                }
            }
        }
        list
    }
}
\end{lstlisting}

Algo válido de se ressaltar é que o uso de \texttt{Some} e \texttt{None} ocorre pois, por vezes, funções retornam um \texttt{Result} que pode ou não conter um valor válido, e esses são os contrutores do tipo. Sendo assim, a linguagem opta por encapsular dessa forma o resultado de certas funções, ao invés de lançar uma exceção(o que geralmente é feito por outras linguagens).

\section{Matriz de Incidência}

Por motivos já citados, esta se trata de uma das abordagens menos interessantes. Ela tem o consumo de memória semelhante a uma Matriz de Adjacência e uma acesso com custo de uma Lista de Adjacência. Mesmo assim, segue a implementação:

\begin{lstlisting}[language=Rust, caption={Implementação de UndirectedGraph na Estrutura de Dados Matriz de Incidência}, label=list:impl_inc_mat_ug]
impl UndirectedGraph<usize> for IncidenceMatrix {
    fn undirected_size(&self) -> usize {
        self.0.len()
    }

    fn connected(&self) -> bool {
        todo!()
    }

    fn undirected_node_degree(&self, vertex: usize) -> usize {
        if self.0.is_empty() || vertex >= self.0[0].len() {
            return 0;
        }

        self.0.iter().filter(|row| row[vertex] != 0).count()
    }
}
\end{lstlisting}

\begin{lstlisting}[language=Rust, caption={Implementação de Graph na Estrutura de Dados Matriz de Incidência}, label=list:impl_inc_mat_g]
impl Graph<usize> for IncidenceMatrix {
    fn new_empty() -> Self {
        IncidenceMatrix(Vec::new())
    }

    fn order(&self) -> usize {
        if self.0.is_empty() {
            0
        } else {
            self.0[0].len()
        }
    }

    fn size(&self) -> usize {
        self.0.len()
    }

    fn node_degrees(&self, _n: usize) -> (usize, usize) {
        todo!()
    }

    fn nodes(&self) -> impl Iterator<Item = usize> {
        0..self.order()
    }

    fn add_node(&mut self, _n: usize) {
        todo!()
    }

    fn remove_node(&mut self, _n: usize) {
        todo!()
    }

    fn add_edge(&mut self, _n: usize, _m: usize) {
        todo!()
    }

    fn remove_edge(&mut self, _n: usize, _m: usize) {
        todo!()
    }

    type Neighbors<'a> = std::iter::FilterMap<
        std::iter::Enumerate<std::slice::Iter<'a, usize>>,
        fn((usize, &'a usize)) -> Option<usize>,
    >;

    fn neighbors<'a>(&'a self, _n: usize) -> Self::Neighbors<'a> {
        todo!()
    }

    fn bipartite(&self) -> bool {
        let n = self.order();
        if n == 0 {
            return true;
        }

        let mut adj = vec![Vec::new(); n];

        for edge in &self.0 {
            let endpoints: Vec<usize> = edge
                .iter()
                .enumerate()
                .filter_map(|(v, &x)| if x != 0 { Some(v) } else { None })
                .collect();

            match endpoints.as_slice() {
                [u, v] => {
                    adj[*u].push(*v);
                    adj[*v].push(*u);
                }
                [u] => {
                    adj[*u].push(*u);
                }
                _ => {}
            }
        }

        let mut partition = vec![None; n];
        let mut queue = std::collections::VecDeque::new();

        for start in 0..n {
            if partition[start].is_some() {
                continue;
            }

            partition[start] = Some(0);
            queue.push_back(start);

            while let Some(u) = queue.pop_front() {
                let u_side = partition[u].unwrap();

                for &v in &adj[u] {
                    if partition[v].is_none() {
                        partition[v] = Some(1 - u_side);
                        queue.push_back(v);
                    } else if partition[v] == Some(u_side) {
                        return false;
                    }
                }
            }
        }

        true
    }

    fn underlying_graph(&self) -> Self {
        todo!()
    }
}
\end{lstlisting}

As funções que tem como conteúdo \texttt{todo!()} têm implementação pendente. Mas algo relevante a se falar é que todas as Estruturas de Dados tem funções de conversão entre si, ou seja:

\begin{lstlisting}[language=Rust, caption={Funções de Conversão}, label=list:convesion]
    pub fn IncidenceMatrix::from_adjacency_matrix(matrix: &AdjacencyMatrix) -> Self;
    pub fn IncidenceMatrix::from_adjacency_list(matrix: &AdjacencyList) -> Self;
\end{lstlisting}

Dito isso, através de composição de funções, todos os resultados de uma instância de \texttt{IncidenceMatrix} poderiam ser obtidos através disso.
