\chapter{Introdução}
\label{ch:intro}

%TODO: Melhorar e extender a introdução
% Isso ficou com uma cara de abstract mal feito...
Este projeto tem como objetivo implementar uma API de
algoritmos relacionados a Grafos na linguagem de programação Rust. A
especificação da API segue as funcionalidades descritas na
definição da Avaliação 01 da disciplina de Grafos, sob o Departamento
de Informática e Matemática Aplicada (DIMAp) da Universidade Federal
do Rio Grande do Norte (UFRN).

Nesta implementação, a especificação da API se materializa em grande
parte como \emph{traços} (\textit{traits}) de Rust. Tal conceito é
semelhante a noção de \textit{interface} em linguagens como Java
e Go e praticamente idêntico ao conceito de \textit{typeclasses} em
linguagens como Haskell. O uso de traços permite que a API seja
flexível e mantenha fidelidade as definições algébricas, além do
mais, permite, por meio da implementação a nível de traço, que o código
seja genérico e eficiente para as diversas representações de grafos.

Além dos traços, fizemos grande uso do conceito de \textit{iteradores}, que
também surgem a partir de traços, essa abstração permite que o código
fique ainda mais reutilizável, sem que a eficiência seja comprometida.

Neste relatório vamos discutir a implementação e apresentar essas
vantagens em detalhes. Além disso, vamos demonstrar empiricamente a
partir de testes de benchmark que apesar do alto nível de abstração,
a eficiência dos algoritmos ainda fica a par de implementações ótimas
feitas em C++.

Para assegurar o comportamento esperado dos algoritmos, também
implementamos mais de 50 testes unitários que testam as
validam as implementações. Entretanto, por causa da extensão dos testes, vamos
disponibilizá-los apenas através do código fonte da API.

\section{Especificação da API}
\label{sec:api_spec}

De acordo com a definição da Avaliação 01 a API deve possuir as
seguintes funcionalidades:

\subsection{Para Grafos Não Direcionados}

\begin{enumerate}
  \item Criação do Grafo a partir da Lista de Adjacências.
  \item Criação do Grafo a partir da Matriz de Adjacências.
  \item Criação do Grafo a partir da Matriz de Incidência.
  \item Conversão de matriz de adjacência para lista de Adjacências e
    vice-versa.
  \item Função que calcula o grau de cada vértice.
  \item Função que determina se dois vértices são adjacentes.
  \item Função que determina o número total de vértices.
  \item Função que determina o número total de arestas.
  \item Inclusão de um novo vértice usando Lista de Adjacências e
    Matriz de Adjacências.
  \item Exclusão de um vértice existente usando Lista de Adjacências
    e Matriz de Adjacências.
  \item Função que determina se um grafo é conexo ou não.
  \item Determinar se um grafo é bipartido.
  \item \label{item:bfs1} Busca em Largura, a partir de um vértice específico.
  \item \label{item:dfs1} Busca em Profundidade, com determinação de arestas de
    retorno, a partir de um vértice em específico.
  \item \label{item:biconnect} Determinação de articulações e
    componentes biconexos, utilizando obrigatoriamente a função \texttt{lowpt}.
\end{enumerate}

\subsection{Para Grafos Direcionados (ou Dígrafos)}

\begin{enumerate}[resume]
  \item Representação do Dígrafo a partir da Matriz de Adjacências.
  \item Representação do Dígrafo a partir da Matriz de Incidência.
  \item Determinação do Grafo subjacente.
  \item \label{item:bfs2} Busca em largura.
  \item \label{item:dfs2} Busca em profundidade, com determinação de
    profundidade de entrada de saída de cada vértice, e arestas de
    árvore, retorno, avanço e cruzamento.
\end{enumerate}

\section{Solução proposta}

\subsection{Traços}

Como discutido brevemente no início do capítulo (\ref{ch:intro}),
nossa solução se baseia na criação de traços e iteradores que vão
implementar os algoritmos descritos na especificação da API
(\ref{sec:api_spec}). Um traço define a funcionalidade que um tipo
tem e que pode compartilhar com outros tipos~\citep{rustbooktraits}.
No nosso caso específico, haverá um traço para grafos não
direcionados, chamado de \texttt{Graph}, e um traço para grafos
direcionados, chamado de \texttt{UndirectedGraph}. O traço
\texttt{UndirectedGraph} herdará as propriedades do traço
\texttt{Graph}, permitindo que os algoritmos definidos em \texttt{Graph}
funcionem em \texttt{UndirectedGraph}. Essa escolha faz sentido
porque na nossa implementação o grafo não direcionado funciona melhor
como uma extensão do grafo direcionado.

\subsection{Iteradores}

Quanto ao uso de iteradores, eles serão implementados
em algoritmos que envolvem algum tipo de travessia no grafo, como a
Busca em Profundidade (DFS) dos items~\ref{item:dfs1} e \ref{item:dfs2}, e a
Busca em Largura (BFS) dos items~\ref{item:bfs1} e \ref{item:bfs2}. A
vantagem de implementar iteradores para esses algoritmos é que
outros algoritmos, como a Determinação de Componentes Biconexos, do
item~\ref{item:biconnect}, fica derivável dessa implementação. Além
disso, a implementação em forma de iteradores permite
que possíveis usuários da API tenham acesso ao extenso framework de iteradores
que a biblioteca padrão de Rust oferece. Alguns exemplos de uso de
iteradores para além da implementação da API, seriam, a determinação de
ciclos no grafo, a determinação de menor caminho entre dois vértices,
a busca por um vértice específico, uma filtragem de vértices durante a
busca, uma modificação do grafo durante a busca, algoritmos de
backtracking e outros, tudo isso apenas compondo a implementação
inicial. É importante ressaltar, também, que o iterador de Rust não
perde desempenho em relação a uma implementação tradicional com
loops~\citep{rustbookIteratorPerformance,
stackoverflowZerocostAbstractions}, inclusive podendo ser mais
ótimo devido a otimizações do compilador. Essa capacidade lhe dá o apelido de
abstração de custo zero.

% TODO: Refletir sobre se devemos adicionar mais informações sobre a
% solução aqui. Falar mais, por exemplo, de abstrações de custo zero,
% leitura de arquivos, etc.

\section{Organização do relatório}

% TODO: Atualizar referência do capítulo 2.
No capítulo 2, vamos apresentar as definições que vamos usar durante
o relatório e construir a base necessária para que o leitor consiga
acompanhar a parte teórica em sua totalidade. Nessa seção revisaremos conceitos
como definição de grafo, vértices, arestas, adjacência,
conectividade e outros.

% TODO: Atualizar referência do capítulo 3.
No capítulo 3, vamos revisar as representações de grafos nas
estruturas de dados que temos disponíveis na linguagem de
programação, estas são, Lista de Adjacência, Matriz de Adjacência e
Matriz de Incidência. Também vamos discorrer um pouco sobre as
vantagens e desvantagens de cada uma.

% TODO: Atualizar referência do capítulo 4.
No capítulo 4, vamos descrever em uma linguagem de pseudocódigo a
implementação dos algoritmos da especificação da API. Novamente, para
preparar o leitor teoricamente para a implementação em Rust.

% TODO: Atualizar referência do capítulo 5.
No capítulo 5, vamos apresentar e discorrer sobre as partes relevantes
do código em Rust que implementa a API e consequentemente as representações e
algoritmos descritos nos capítulos 3 e 4.

% TODO: Atualizar referência do capítulo 6.
No capítulo 6, vamos demonstrar porque as abstrações utilizadas na
implementação é zero custo comparando sua performance com uma
implementação tradicional em C++.

% TODO: Atualizar referência do capítulo 7.
No capítulo 7, vamos discutir as possíveis melhorias a nossa API e quais
podem ser os futuros próximos passos.

No apêndice A, você poderá consultar as atividades desenvolvidas por
cada integrante.
